import 'dart:async';
import 'package:flutter/material.dart';
import '../models/appointment_model.dart';
import '../models/doctor_model.dart';
import '../providers/auth_provider.dart';
import '../services/firestore_service.dart';

/// Manages the user's appointments: booking, cancellation, and retrieval.
/// Depends on AuthProvider to get the current user ID.
class AppointmentProvider with ChangeNotifier {
  final AuthProvider _authProvider;
  final FirestoreService _firestoreService = FirestoreService();
  
  List<AppointmentModel> _userAppointments = [];
  bool _isLoading = false;
  String? _errorMessage;
  
  // Stream subscription to track the user's appointments
  StreamSubscription<List<AppointmentModel>>? _appointmentsSubscription;

  List<AppointmentModel> get userAppointments => _userAppointments;
  bool get isLoading => _isLoading;
  String? get errorMessage => _errorMessage;

  AppointmentProvider(this._authProvider) {
    // Start listening to appointments as soon as the provider is created
    // and whenever the user logs in/out (handled by the ProxyProvider in main.dart)
    _subscribeToAppointments();
  }

  /// Subscribes to the user's private appointment collection in Firestore.
  void _subscribeToAppointments() {
    _appointmentsSubscription?.cancel(); // Cancel any existing subscription
    
    final userId = _authProvider.user?.id;

    if (userId == null) {
      // User is logged out, clear data
      _userAppointments = [];
      _isLoading = false;
      notifyListeners();
      return;
    }

    _isLoading = true;
    _errorMessage = null;
    notifyListeners();

    try {
      _appointmentsSubscription = _firestoreService.streamUserAppointments(userId).listen(
        (appointmentsList) {
          _userAppointments = appointmentsList;
          _isLoading = false;
          _errorMessage = null;
          notifyListeners();
        },
        onError: (error) {
          _errorMessage = 'Failed to load appointments: $error';
          _isLoading = false;
          print('Appointment Stream Error: $error');
          notifyListeners();
        },
      );
    } catch (e) {
      _errorMessage = 'Initialization error for appointments: $e';
      _isLoading = false;
      notifyListeners();
    }
  }

  // NOTE: This method must be called when AuthProvider state changes (handled by ProxyProvider).
  // This ensures the stream is updated when the user signs in or out.
  void update(AuthProvider auth) {
    if (auth.user?.id != _authProvider.user?.id) {
      _subscribeToAppointments(); // Resubscribe if the user ID has changed
    }
  }


  // =========================================================================
  // APPOINTMENT ACTIONS
  // =========================================================================

  /// Books a new appointment for the logged-in user.
  Future<void> bookAppointment({
    required DoctorModel doctor,
    required DateTime dateTime,
    required String reason,
  }) async {
    final userId = _authProvider.user?.id;
    if (userId == null) {
      throw Exception("User must be logged in to book an appointment.");
    }
    
    _isLoading = true;
    notifyListeners();

    try {
      final newAppointment = AppointmentModel(
        // ID will be generated by Firestore
        id: '', 
        patientId: userId,
        doctorId: doctor.id,
        doctorName: doctor.name,
        doctorSpecialty: doctor.specialty,
        appointmentDateTime: dateTime,
        consultationFee: doctor.consultationFee,
        reason: reason,
        status: 'Confirmed', // Typically 'Pending' or 'Confirmed' based on logic
      );

      await _firestoreService.bookAppointment(userId, newAppointment);
      _errorMessage = null;
      // The stream will automatically update _userAppointments list
    } catch (e) {
      _errorMessage = 'Failed to book appointment: ${e.toString()}';
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }
  
  /// Cancels an existing appointment.
  Future<void> cancelAppointment(String appointmentId) async {
    final userId = _authProvider.user?.id;
    if (userId == null) return; 

    _isLoading = true;
    notifyListeners();

    try {
      // Set status to 'Cancelled'
      await _firestoreService.updateAppointmentStatus(
        userId, 
        appointmentId, 
        'Cancelled'
      );
      _errorMessage = null;
    } catch (e) {
      _errorMessage = 'Failed to cancel appointment: ${e.toString()}';
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  @override
  void dispose() {
    _appointmentsSubscription?.cancel();
    super.dispose();
  }
}